# matches-filter.iq - Tests for the MATCHES_FILTER function, which
# implements Looker-style filter expressions.
#
# Licensed to the Apache Software Foundation (ASF) under one or more
# contributor license agreements.  See the NOTICE file distributed with
# this work for additional information regarding copyright ownership.
# The ASF licenses this file to you under the Apache License, Version 2.0
# (the "License"); you may not use this file except in compliance with
# the License.  You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
!use scott-calcite
!set outputformat csv

#####################################################################
# Strings

!if (false) {
# pattern 'FOO': is equal to "FOO", exactly
with t (v) as (values 'FOO', 'FOOD')
select v, matches_filter(v, 'FOO') as b from t;
V, B
FOO, true
FOOD, false
foo, true
!ok

# pattern 'FOO,BAR': is equal to either "FOO" or "BAR", exactly
with t (v) as (values 'FOO', 'FOOD', 'BAR', 'BAZ', 'FOO,BAR')
select v, matches_filter(v, 'FOO,BAR') as b from t;
V, B
FOO, true
FOOD, false
BAR, true
BAZ, false
FOO,BAR, false
!ok

# pattern '%FOO%': contains "FOO", matches "buffoon" and "fast food"
with t (v) as (values 'buffoon', 'fast food', 'baz')
select v, matches_filter(v, '%FOO%') as b from t;
V, B
buffoon, true
fast food, true
baz, false
!ok

# pattern 'FOO%': starts with "FOO", matches "foolish" and "food" but not
# "buffoon" or "fast food"
with t (v) as (values 'foolish', 'food', 'buffoon', 'fast food')
select v, matches_filter(v, 'FOO%') as b from t;
V, B
foolish, true
food, true
buffoon, false
fast food, false
!ok
!}

# Pattern '%FOO': ends with "FOO", matches "buffoo" and "fast foo" but
# not "buffoon" or "fast food"

# Pattern 'F%OD': starts with an "F" and ends with "OD", matches "fast
# food"

# Pattern 'EMPTY': string is empty (has zero characters) or is null
# (no value)

# Pattern 'NULL': value is null (when it is used as part of a LookML
# filter expression, place NULL in quotes, as shown on the filters
# documentation page)

# Pattern '-FOO': is not equal to "FOO" (is any value except "FOO"),
# matches "pizza", "trash", "fun" but not "foo"

# Pattern '-FOO,-BAR': is not equal to either "FOO" or "BAR", matches
# any value except "FOO" and "BAR"

# Pattern '-%FOO%': doesn't contain "FOO", does not match "buffoon" or
# "fast food"

# Pattern '-FOO%': doesn't start with "FOO", does not match "foolish"
# or "food"

# Pattern '-%FOO': doesn't end with "FOO", does not match "buffoo" or
# "fast foo"

# Pattern '-EMPTY': string is not empty (has at least one character)

# Pattern '-NULL': value of column is not null (when it is used as
# part of a LookML filter expression, place -NULL in quotes, as shown
# on the filters documentation page)

# Pattern 'FOO%,BAR': starts with "FOO" or is "BAR" exactly, matches
# "food" and matches "bar" but not "barfood"

# Pattern 'FOO%,-FOOD': starts with "FOO" but is not "FOOD"

# Pattern '_UF': has any single character followed by "UF", matches
# "buffoon"

#####################################################################
# Date and Time

# Pattern 'this {interval}': this month': You can use this week, this
# month, this quarter, or this year. Note that this day isn't
# supported. If you want to get data from the current day, you can use
# today.

# Pattern '{n} {interval}': 3 days

# Pattern '{n} {interval} ago': 3 days ago

# Pattern '{n} {interval} ago for {n} {interval}': 3 months ago for 2
# days

# Pattern 'before {n} {interval} ago': before 3 days ago

# Pattern 'before {time}': before 2018-01-01 12:00:00': before is not
# inclusive of the time you specify. The expression before 2018-01-01
# will return data from all dates before 2018-01-01, but it won't
# return data from 2018-01-01.

# Pattern 'after {time}': after 2018-10-05': after is inclusive of the
# time you specify. So, the expression after 2018-10-05 will return
# data from 2018-10-05 and all dates later than 2018-10-05.

# Pattern '{time} to {time}': 2018-05-18 12:00:00 to

# Pattern '2018-05-18 14:00:00': The initial time value is inclusive
# but the latter time value is not. So the expression 2018-05-18
# 12:00:00 to 2018-05-18 14:00:00 will return data with the time
# "2018-05-18 12:00:00" through "2018-05-18 13:59:59".

# Pattern 'this {interval} to {interval}': this year to second': The
# beginning of each interval is used. For example, the expression this
# year to second returns data from the beginning of the year the query
# is run through to the beginning of the second the query is run. this
# week to day returns data from the beginning of the week the query is
# run through to the beginning of the day the query is run.

# Pattern '{time} for {n} {interval}': 2018-01-01 12:00:00 for 3 days

# Pattern 'today': today

# Pattern 'yesterday': yesterday

# Pattern 'tomorrow': tomorrow

# Pattern '{day of week}': Monday': Specifying a day of week with a
# Dimension Group Date field returns the most recent date that matches
# the specified day of week. For example, the expression Dimension
# Group Date matches (advanced) Monday returns the most recent Monday.

# Pattern 'You can also use {day of week} with the before and after
# keywords in this context. For example, the expression Dimension
# Group Date matches (advanced) after Monday returns the most recent
# Monday and everything after the most recent Monday. The expression
# Dimension Group Date matches (advanced) before Monday returns every
# day before the most recent Monday, but it doesn't return the most
# recent Monday.

# Pattern 'Specifying a day of the week with a Dimension Group Day of
# Week field returns every day that matches the specified day of
# week. So the expression Dimension Group Day of Week matches
# (advanced) Monday returns every Monday.

# Pattern 'next {week, month, quarter, fiscal quarter, year, fiscal
# year}': next week': The next keyword is unique in that it requires
# one of the intervals listed previously and won't work with other
# intervals.

# Pattern '{n} {interval} from now': 3 days from now

# Pattern '{n} {interval} from now for {n} {interval}': 3 days from
# now for 2 weeks

## Absolute dates

# Absolute date filters use the specific date values to generate query
# results.  These are useful when creating queries for specific date
# ranges.

# Pattern '2018/05/29': sometime on 2018/05/29

# Pattern '2018/05/10 for 3 days': from 2018/05/10 00:00:00 through
# 2018/05/12 23:59:59

# Pattern 'after 2018/05/10': 2018/05/10 00:00:00 and after

# Pattern 'before 2018/05/10': before 2018/05/10 00:00:00

# Pattern '2018/05': within the entire month of 2018/05

# Pattern '2018/05 for 2 months': within the entire months of 2018/05
# and 2018/06

# Pattern '2018/05/10 05:00 for 5 hours': from 2018/05/10 05:00:00
# through 2018/05/10 09:59:59

# Pattern '2018/05/10 for 5 months': from 2018/05/10 00:00:00 through
# 2018/10/09 23:59:59

# Pattern '2018': entire year of 2018 (2018/01/01 00:00:00 through
# 2018/12/31 23:59:59)

# Pattern 'FY2018': entire fiscal year starting in 2018 (if your
# Looker developers have specified that your fiscal year starts in
# April then this is 2018/04/01 00:00 through 2019/03/31 23:59)

# Pattern 'FY2018-Q1': first quarter of the fiscal year starting in
# 2018 (if your Looker developers have specified that your fiscal year
# starts in April then this is 2018/04/01 00:00:00 through 2018/06/30
# 23:59:59)

## Relative dates

# Relative date filters allow you to create queries with rolling date
# values relative to the current date. These are useful when creating
# queries that update each time you run the query.

# For all of the following examples, assume today is Friday,
# 2018/05/18 18:30:02.

# TODO: create a means to set the current date/time/timestamp for the
#   current session CURRENT_TIMESTAMP etc. will return those values.
#   Then enable the CURRENT_x tests.
!if (false) {
!set timestamp '2018-05-18 18:30:02'
!}

### Seconds

# Pattern '1 second': the current second (2018/05/18 18:30:02)
!if (false) {
with t (v) as (values timestamp '2018-05-18 18:30:02',
                      timestamp '2018-05-18 18:30:02.8',
                      timestamp '2018-05-18 18:30:03')
select v, matches_filter(v, '1 second') as b from t;
V, B
2018-05-18 18:30:02, true
2018-05-18 18:30:02.8, true
2018-05-18 18:30:03, false
!ok
!}

# Pattern '60 seconds': 60 seconds ago for 60 seconds (2018/05/18 18:29:02
# through 2018/05/18 18:30:01)
!if (false) {
with t (v) as (values timestamp '2018-05-18 18:29:02',
                      timestamp '2018-05-18 18:30:01',
                      timestamp '2018-05-18 18:30:02')
select v, matches_filter(v, 'FOO') as b from t;
V, B
2018-05-18 18:29:02, true
2018-05-18 18:30:01, true
2018-05-18 18:30:02, false
!ok
!}

# Pattern '60 seconds ago for 1 second': 60 seconds ago for 1 second
# (2018/05/18 18:29:02)

### Minutes

# Pattern '1 minute': the current minute (2018/05/18 18:30:00 through
# 18:30:59)

# Pattern '60 minutes': 60 minutes ago for 60 minutes (2018/05/18
# 17:31:00 through 2018/05/18 18:30:59)

# Pattern '60 minutes ago for 1 minute': 60 minutes ago for 1 minute
# (2018/05/18 17:30:00 through 2018/05/18 17:30:59)

### Hours

# Pattern '1 hour': the current hour (2018/05/18 18:00 through
# 2018/05/18 18:59)

# Pattern '24 hours': the same hour of day that was 24 hours ago for
# 24 hours (2018/05/17 19:00 through 2018/05/18 18:59)

# Pattern '24 hours ago for 1 hour': the same hour of day that was 24
# hours ago for 1 hour (2018/05/17 18:00 until 2018/05/17 18:59)

### Days

# Pattern 'today': the current day (2018/05/18 00:00 through
# 2018/05/18 23:59)

# Pattern '2 days': all of yesterday and today (2018/05/17 00:00
# through 2018/05/18 23:59)

# Pattern '1 day ago': just yesterday (2018/05/17 00:00 until
# 2018/05/17 23:59)

# Pattern '7 days ago for 7 days': the last complete 7 days
# (2018/05/11 00:00 until 2018/05/17 23:59)

# Pattern 'today for 7 days': the current day, starting at midnight,
# for 7 days into the future (2018/05/18 00:00 until 2018/05/24 23:59)

# Pattern 'last 3 days': 2 days ago through the end of the current day
# (2018/05/16 00:00 until 2018/05/18 23:59)

# Pattern '7 days from now': 7 days in the future (2018/05/18 00:00
# until 2018/05/25 23:59)

### Weeks

# Pattern '1 week': top of the current week going forward (2018/05/14
# 00:00 through 2018/05/20 23:59)

# Pattern 'this week': top of the current week going forward
# (2018/05/14 00:00 through 2018/05/20 23:59)

# Pattern 'before this week': anytime until the top of this week
# (before 2018/05/14 00:00)

# Pattern 'after this week': anytime after the top of this week
# (2018/05/14 00:00 and later)

# Pattern 'next week': the following Monday going forward 1 week
# (2018/05/21 00:00 through 2018/05/27 23:59)

# Pattern '2 weeks': a week ago Monday going forward (2018/05/07 00:00
# through 2018/05/20 23:59)

# Pattern 'last week': synonym for "1 week ago"

# Pattern '1 week ago': a week ago Monday going forward 1 week
# (2018/05/07 00:00 through 2018/05/13 23:59)

### Months

# Pattern '1 month': the current month (2018/05/01 00:00 through
# 2018/05/31 23:59)

# Pattern 'this month': synonym for "0 months ago" (2018/05/01 00:00
# through 2018/05/31 23:59)

# Pattern '2 months': the past two months (2018/04/01 00:00 through
# 2018/05/31 23:59)

# Pattern 'last month': all of 2018/04

# Pattern '2 months ago': all of 2018/03

# Pattern 'before 2 months ago': all time before 2018/03/01

# Pattern 'next month': all of 2018/06

# Pattern '2 months from now': all of 2018/07

# Pattern '6 months from now for 3 months': 2018/11 through 2019/01

### Quarters

# Pattern '1 quarter': the current quarter (2018/04/01 00:00 through
# 2018/06/30 23:59)

# Pattern 'this quarter': synonym for "0 quarters ago" (2018/04/01
# 00:00 through 2018/06/30 23:59)

# Pattern '2 quarters': the past two quarters (2018/01/01 00:00
# through 2018/06/30 23:59)

# Pattern 'last quarter': all of Q1 (2018/01/01 00:00 through
# 2018/03/31 23:59)

# Pattern '2 quarters ago': all of Q4 of last year (2017/010/01 00:00
# through 2017/12/31 23:59)

# Pattern 'before 2 quarters ago': all time before Q4 of last year

# Pattern 'next quarter': all of the following quarter (2018/07/01
# 00:00 through 2018/09/30 23:59)

# Pattern '2018-07-01 for 1 quarter': all of Q3 (2018/07/01 00:00
# through 2018/09/30 23:59)

# Pattern '2018-Q4': all of Q4 (2018/10/01 00:00 through 2018/12/31 23:59)
#
# Note: If your Looker developers have specified using a fiscal year
# then you can type fiscal in these expressions to use a fiscal
# quarter instead of a calendar quarter. For example, you can use last
# fiscal quarter.

### Years

# Pattern '1 year': all of the current year (2018/01/01 00:00 through
# 2018/12/31 23:59)

# Pattern 'this year': all of the current year (2018/01/01 00:00
# through 2018/12/31 23:59)

# Pattern 'next year': all of the following year (2019/01/01 00:00
# through 2019/12/31 23:59)

# Pattern '2 years': the past two years (2017/01/01 00:00 through
# 2018/12/31 23:59)

# Pattern 'last year': all of 2017

# Pattern '2 years ago': all of 2016

# Pattern 'before 2 years ago': all time before 2016/01/01 (does not
# include any days between 2016/01/01 and 2016/05/18)
#
# Note: If your Looker developers have specified using a fiscal year
# then you can type fiscal in these expressions to use a fiscal year
# instead of a calendar quarter. For example, you can use last fiscal
# year.

#####################################################################
# Boolean

# Filtering on true or false type values in requires you to know what
# type of true or false value you're interacting with.

# Pattern 'yes or Yes': field evaluates to true
#
# Looker developers: for type: yesno dimensions use lowercase, for
# filters parameters (like those used in a measure or used in an
# always_filter) use uppercase

# Pattern 'no or No': field evaluates to false
#
# Looker developers: for type: yesno dimensions use lowercase, for
# filters parameters (like those used in a measure or used in an
# always_filter) use uppercase

# Pattern 'TRUE': field contains true (for fields that contain Boolean
# database values)

# Pattern 'FALSE': field contains false (for fields that contain
# Boolean database values)

#####################################################################
# Number

# Filters on numbers support both natural language expressions (for
# example, '3 to 10') and relational operators (for example,
# '>20'). Looker supports the OR operator to express multiple filter
# ranges (for example, '3 to 10 OR 30 to 100'). The AND operator can
# be used to express numeric ranges with relational operators (for
# example, '>=3 AND <=10') to specify a range. Filters on numbers can
# also use algebraic interval notation to filter numeric fields.

# Note: The syntax for numeric filter expressions using NOT may not be
# intuitive. If the first filter condition contains a NOT, and no
# other filter conditions contains a NOT, then all of the filter
# conditions will be negated.  See the following examples for more
# information.

with t (v) as (values 1, 2, 3)
select v, matches_filter(v, '1,2,4') as b from t;
V, B
1, true
2, true
3, false
!ok

with t (v) as (values 1, 8, 10)
select v, matches_filter(v, '> 8') as b from t;
V, B
1, false
8, false
10, true
!ok

with t (v) as (values -3, -2, -1, 0, 1)
select v, matches_filter(v, '> -2') as b from t;
V, B
-3, false
-2, false
-1, true
0, true
1, true
!ok

with t (v) as (values -1, 1, 8, 10)
select v, matches_filter(v, '< 8') as b from t;
V, B
-1, true
1, true
8, false
10, false
!ok

with t (v) as (values -1, 1, 20, 30, 40)
select v, matches_filter(v, '[0, 20], > 30') as b from t;
V, B
-1, false
1, true
20, true
30, false
40, true
!ok

# Pattern '5': is exactly 5
with t (v) as (values -3, -2, 5, 6)
select v, matches_filter(v, '5') as b from t;
V, B
-3, false
-2, false
5, true
6, false
!ok

# Pattern 'NOT 5' or '<>5' or '!=5': is any value but exactly 5
with t (v) as (values -3, -2, 5, 6)
select v, matches_filter(v, 'NOT 5') as b1,
          matches_filter(v, '<> 5') as b2,
          matches_filter(v, '!=5') as b3 from t;
V, B1, B2, B3
-3, true, true, true
-2, true, true, true
5, false, false, false
6, true, true, true
!ok

# Pattern '1, 3, 5, 7': is one of the values 1, 3, 5, or 7, exactly
with t (v) as (values -3, -2, 5, 6)
select v, matches_filter(v, '1, 3, 5, 7') as b from t;
V, B
-3, false
-2, false
5, true
6, false
!ok

# Pattern 'NOT 66, 99, 4': is not one of the values 66, 99, or 4, exactly
with t (v) as (values -3, -2, 4, 5, 66, 77)
select v, matches_filter(v, 'NOT 66, 99, 4') as b from t;
V, B
-3, true
-2, true
4, false
5, true
66, false
77, true
!ok

# Pattern '>1 AND <100, NOT 2': is greater than 1 and less than 100, is not 2

# Pattern 'NOT >1, 2, <100': is less than or equal to 1, is not 2, and
# is greater than or equal to 100 (Looker recognizes that this is an
# impossible condition, and will instead write the SQL 'IS NULL')

# Pattern '5, NOT 6, NOT 7': is 5, is not 6 or 7

# Pattern '5.5 to 10' or '>=5.5 AND <=10': is 5.5 or greater but also
# 10 or less

# Pattern 'NOT 3 to 80.44' or '<3 OR >80.44': is less than 3 or
# greater than 80.44

# Pattern '1 to' or '>=1': is 1 or greater

# Pattern 'to 10' or '<=10': is 10 or less

# Pattern '>10 AND <=20 OR 90': is greater than 10 and less than or
# equal to 20, or is 90 exactly

# Pattern '>=50 AND <=100 OR >=500 AND <=1000': is between 50 and 100,
# inclusive, or between 500 and 1000, inclusive

# Pattern 'NULL': has no data in it (when it is used as part of a
# LookML filter expression, place NULL in quotes, as shown on the
# filters documentation page)

# Pattern 'NOT NULL': has some data in it (when it is used as part of
# a LookML filter expression, place NOT NULL in quotes, as shown on
# the filters documentation page)

# Pattern '(1, 7)': interpreted as 1 < x < 7 where the endpoints
# aren't included. While this notation resembles an ordered pair, in
# this context it refers to the interval upon which you are working.

# Pattern '[5, 90]': interpreted as 5 <= x <= 90 where the endpoints
# are included

# Pattern '(12, 20]': interpreted as 12 < x <= 20 where 12 is not
# included, but 20 is included

# Pattern '[12, 20)': interpreted as 12 <= x < 20 where 12 is
# included, but 20 is not included

# Pattern '(500, inf)': interpreted as x > 500 where 500 is not
# included and infinity is always expressed as being "open" (not
# included). inf may be omitted and '(500, inf)' may be written as
# '(500,)'

# Pattern '(-inf, 10]': interpreted as x <= 10 where 10 is included
# and infinity is always expressed as being "open" (not
# included). 'inf' may be omitted and '(-inf, 10]' may be written as
# '(,10]'

# Pattern '[0,9],[20,29]': the numbers between 0 and 9 inclusive or 20
# to 29 inclusive

# Pattern '[0,10],20': 0 to 10 inclusive or 20

# Pattern 'NOT (3,12)': interpreted as x < 3 and x > 12

#####################################################################
# Location

# Location filter expressions are based on latitude and longitude, but can
# accept some natural language to define boxes and circles within which to limit
# a search.

# Pattern '36.97, -122.03': location is exactly at latitude 36.97, longitude
# 122.03

# Pattern '40 miles from 36.97, -122.03': location is within 40 miles of
# latitude 36.97, longitude -122.03

# Pattern 'inside box from 72.33, -173.14 to 14.39, -61.70': location is within
# a box whose northwest corner is at latitude 72.33, longitude -173.14, and
# whose southeast corner is at latitude 14.39, longitude -61.70

# Pattern 'NOT NULL' (works the same as '-NULL'): location has both a non-null
# latitude and a non-null longitude (when it is used as part of a LookML filter
# expression, place 'NOT NULL' in quotes, as shown on the filters documentation
# page)

# Pattern '-NULL' (works the same as 'NOT NULL'): location has both a non-null
# latitude and a non-null longitude (when it is used as part of a LookML filter
# expression, place '-NULL' in quotes, as shown on the filters documentation
# page)

# Pattern 'NULL': location has a null latitude, or a null longitude, or both are
# null (when it is used as part of a LookML filter expression, place NULL in
# quotes, as shown on the filters documentation page)

# Supported units of measurement

# To filter in an area around a certain location, you can use these units:
# Meters
# Feet
# Kilometers
# Miles
#
# Singular units of measurement aren't supported. For example, filtering for a
# one-mile radius should be written 'within 1 miles of 36.97, -122.03'.

#####################################################################
# User Attribute Values

# To use the value of a user attribute in a filter expression, reference the
# user attribute with the _user_attributes Liquid variable using the syntax that
# is required by your database dialect:
#
#   {{ _user_attributes['name_of_attribute'] }}
#
# For example, suppose you need to apply an 'sf_' prefix to the value of the
# 'salesforce_username' user attribute because that is how the values are stored
# in your database. To add the prefix to the user attribute value, you can add a
# matches (advanced) filter on the relevant field and use the '_user_attributes'
# Liquid variable in the filter expression as follows:
#
#   sf_{{_user_attributes['salesforce_username']}}

# End matches-filter.iq
