# measure.iq - measure expressions
#
# Licensed to the Apache Software Foundation (ASF) under one or more
# contributor license agreements.  See the NOTICE file distributed with
# this work for additional information regarding copyright ownership.
# The ASF licenses this file to you under the Apache License, Version 2.0
# (the "License"); you may not use this file except in compliance with
# the License.  You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
!set outputformat mysql
!use scott

# View with one measure
create view empm as
select *, 1 as measure avg_sal
from emp;
(0 rows modified)

!update

!if (viewExpand) {
# Aggregate query with naked measure
select job, avg_sal as a
from empm
group by job;
!ok

# Same query using subquery
select job, avg_sal as a
from (
 select *, 1 as measure avg_sal
 from "scott".emp
) as empm
group by job;
!ok

# Same query using CTE
with empm as (
  select *, 1 as measure avg_sal
  from emp
)
select job, avg_sal as a
from empm
group by job;
!ok

# Equivalent using AGGREGATE
select job, aggregate(avg_sal) as a
from empm
group by job;
!ok
!}

# AGGREGATE may not be applied to non-measure
select aggregate(deptno)
from empm
group by job;
Argument to function 'AGGREGATE' must be a measure
!error

# AGGREGATE makes a query into an aggregate query, and therefore non-grouped
# columns are illegal.
select aggregate(avg_sal) as a, deptno
from empm;
Expression 'DEPTNO' is not being grouped
!error

!if (viewExpand) {
# As above, but without AGGREGATE, is valid.
select avg_sal as a, deptno
from empm;
!ok
!}

# Measure that references another measure
select *
from (
  select deptno,
    empno + 1 as measure e1,
    e1 + deptno as measure e2
  from "scott".emp
  where job = 'CLERK');
+--------+------+------+
| DEPTNO | E1   | E2   |
+--------+------+------+
|     20 | 7370 | 7390 |
|     20 | 7877 | 7897 |
|     30 | 7901 | 7931 |
|     10 | 7935 | 7945 |
+--------+------+------+
(4 rows)

!ok

# Measure may reference non-measure alias
select deptno + 1 as d1,
  d1 + 2 as measure d3
from "scott".dept;
+----+----+
| D1 | D3 |
+----+----+
| 11 | 13 |
| 21 | 23 |
| 31 | 33 |
| 41 | 43 |
+----+----+
(4 rows)

!ok

# In a measure ('d'), qualified references give you the column, and unqualified
# references give the alias. In a regular select item ('d2'), qualified and
# unqualified references give the column.
select e.empno + 1 as deptno,
 deptno + e.deptno as measure d,
 deptno + e.deptno as d2
from "scott".emp as e
where job = 'CLERK';
+--------+------+----+
| DEPTNO | D    | D2 |
+--------+------+----+
|   7370 | 7390 | 40 |
|   7877 | 7897 | 40 |
|   7901 | 7931 | 60 |
|   7935 | 7945 | 20 |
+--------+------+----+
(4 rows)

!ok

# Measure used in GROUP BY query
!if (false) {
select deptno, count_plus_100
from (
  select empno, deptno, job, count(*) + 100 as measure count_plus_100
  from "scott".emp)
group by deptno;
!ok
!}

# As above, using AGGREGATE function
!if (false) {
select deptno, count_plus_100
from (
  select empno, deptno, job, count(*) + 100 as measure count_plus_100
  from "scott".emp)
group by deptno;
!ok
!}

# Aggregate measure used in non-aggregate query
select empno, count_plus_100
from (
  select empno, deptno, job, count(*) + 100 as measure count_plus_100
  from "scott".emp);
+-------+----------------+
| EMPNO | COUNT_PLUS_100 |
+-------+----------------+
|  7369 |            101 |
|  7499 |            101 |
|  7521 |            101 |
|  7566 |            101 |
|  7654 |            101 |
|  7698 |            101 |
|  7782 |            101 |
|  7788 |            101 |
|  7839 |            101 |
|  7844 |            101 |
|  7876 |            101 |
|  7900 |            101 |
|  7902 |            101 |
|  7934 |            101 |
+-------+----------------+
(14 rows)

!ok
EnumerableCalc(expr#0..8=[{inputs}], expr#9=[100], expr#10=[+($t8, $t9)], EMPNO=[$t0], COUNT_PLUS_100=[$t10])
  EnumerableWindow(window#0=[window(rows between CURRENT ROW and CURRENT ROW aggs [COUNT()])])
    EnumerableTableScan(table=[[scott, EMP]])
!plan

# Aggregate measure used in non-aggregate query with ORDER BY
select empno, count_plus_100
from (
  select empno, deptno, job, count(*) + 100 as measure count_plus_100
  from "scott".emp)
order by 1;
+-------+----------------+
| EMPNO | COUNT_PLUS_100 |
+-------+----------------+
|  7369 |            101 |
|  7499 |            101 |
|  7521 |            101 |
|  7566 |            101 |
|  7654 |            101 |
|  7698 |            101 |
|  7782 |            101 |
|  7788 |            101 |
|  7839 |            101 |
|  7844 |            101 |
|  7876 |            101 |
|  7900 |            101 |
|  7902 |            101 |
|  7934 |            101 |
+-------+----------------+
(14 rows)

!ok

!if (false) {
# Aggregate measure used in non-aggregate query with WHERE and ORDER BY
select empno, count_plus_100
from (
  select empno, deptno, job, count(*) + 100 as measure count_plus_100
  from "scott".emp)
where deptno = 10
order by 1;
!ok

# Aggregate measure
select deptno, count_plus_100
from (
  select empno, deptno, job, count(*) + 100 as measure count_plus_100
  from "scott".emp)
group by deptno;
!ok

# Measure based on distinct aggregate
select deptno, cdj1
from (
  select empno, deptno, job, count(distinct job) + 1 as measure cdj1
  from "scott".emp)
group by deptno;
!ok
!}

# End measure.iq
